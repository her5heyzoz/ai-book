第 1部分　PyTorch核心
第　1章 深度学习和PyTorch库简介　3
1．1　深度学习革命　4
1．2　PyTorch深度学习　5
1．3　为什么用PyTorch　6
1．4　PyTorch如何支持深度学习概述　8
1．5　硬件和软件要求　10
1．6　练习题　12
1．7　本章小结　13
第　2章 预训练网络　14
2．1　一个识别图像主体的预训练网络　15
2．1．1　获取一个预先训练好的网络用于图像识别　16
2．1．2　AlexNet　17
2．1．3　ResNet　19
2．1．4　准备运行　19
2．1．5　运行模型　21
2．2　一个足以以假乱真的预训练模型　23
2．2．1　GAN游戏　24
2．2．2　CycleGAN　25
2．2．3　一个把马变成斑马的网络　26
2．3　一个描述场景的预训练网络　29
2．4　Torch Hub　31
2．5　总结　32
2．6　练习题　32
2．7　本章小结　33
第3章　从张量开始　34
3．1　实际数据转为浮点数　34
3．2　张量：多维数组　36
3．2．1　从Python列表到PyTorch张量　36
3．2．2　构造第 1个张量　37
3．2．3　张量的本质　37
3．3　索引张量　40
3．4　命名张量　40
3．5　张量的元素类型　43
3．5．1　使用dtype指定数字类型　43
3．5．2　适合任何场合的dtype　44
3．5．3　管理张量的dtype属性　44
3．6　张量的API　45
3．7　张量的存储视图　46
3．7．1　索引存储区　47
3．7．2　修改存储值：就地操作　48
3．8　张量元数据：大小、偏移量和步长　48
3．8．1　另一个张量的存储视图　49
3．8．2　无复制转置　51
3．8．3　高维转置　52
3．8．4　连续张量　53
3．9　将张量存储到GPU　55
3．10　NumPy互操作性　57
3．11　广义张量也是张量　57
3．12　序列化张量　58
3．13　总结　60
3．14　练习题　60
3．15　本章小结　60
第4章　使用张量表征真实数据　61
4．1　处理图像　62
4．1．1　添加颜色通道　62
4．1．2　加载图像文件　63
4．1．3　改变布局　63
4．1．4　正规化数据　64
4．2　三维图像：体数据　65
4．3　表示表格数据　66
4．3．1　使用真实的数据集　67
4．3．2　加载葡萄酒数据张量　68
4．3．3　表示分数　70
4．3．4　独热编码　70
4．3．5　何时分类　72
4．3．6　寻找阈值　73
4．4　处理时间序列　75
4．4．1　增加时间维度　76
4．4．2　按时间段调整数据　77
4．4．3　准备训练　79
4．5　表示文本　81
4．5．1　将文本转化为数字　81
4．5．2　独热编码字符　82
4．5．3　独热编码整个词　83
4．5．4　文本嵌入　85
4．5．5　作为蓝图的文本嵌入　87
4．6　总结　88
4．7　练习题　88
4．8　本章小结　88
第5章　学习的机制　90
5．1　永恒的建模经验　90
5．2　学习就是参数估计　92
5．2．1　一个热点问题　93
5．2．2　收集一些数据　93
5．2．3　可视化数据　94
5．2．4　选择线性模型首试　94
5．3　减少损失是我们想要的　95
5．4　沿着梯度下降　98
5．4．1　减小损失　99
5．4．2　进行分析　99
5．4．3　迭代以适应模型　101
5．4．4　归一化输入　104
5．4．5　再次可视化数据　106
5．5　PyTorch自动求导：反向传播的一切　107
5．5．1　自动计算梯度　107
5．5．2　优化器　111
5．5．3　训练、验证和过拟合　115
5．5．4　自动求导更新及关闭　120
5．6　总结　121
5．7　练习题　122
5．8　本章小结　122
第6章　使用神经网络拟合数据　123
6．1　人工神经网络　124
6．1．1　组成一个多层网络　125
6．1．2　理解误差函数　125
6．1．3　我们需要的只是激活函数　126
6．1．4　更多激活函数　128
6．1．5　选择最佳激活函数　128
6．1．6　学习对于神经网络意味着什么　129
6．2　PyTorch nn模块　131
6．2．1　使用__call__()而不是forward()　132
6．2．2　回到线性模型　133
6．3　最终完成一个神经网络　137
6．3．1　替换线性模型　137
6．3．2　检查参数　138
6．3．3　与线性模型对比　141
6．4　总结　142
6．5　练习题　142
6．6　本章小结　142
第7章　区分鸟和飞机：从图像学习　143
7．1　微小图像数据集　143
7．1．1　下载CIFAR-10　144
7．1．2　Dataset类　145
7．1．3　Dataset变换　146
7．1．4　数据归一化　149
7．2　区分鸟和飞机　150
7．2．1　构建数据集　151
7．2．2　一个全连接模型　152
7．2．3　分类器的输出　153
7．2．4　用概率表示输出　154
7．2．5　分类的损失　157
7．2．6　训练分类器　159
7．2．7　全连接网络的局限　165
7．3　总结　167
7．4　练习题　167
7．5　本章小结　168
第8章　使用卷积进行泛化　169
8．1　卷积介绍　169
8．2　卷积实战　172
8．2．1　填充边界　173
8．2．2　用卷积检测特征　175
8．2．3　使用深度和池化技术进一步研究　177
8．2．4　为我们的网络整合一切　179
8．3　子类化nn．Module　181
8．3．1　将我们的网络作为一个nn．Module　182
8．3．2　PyTorch如何跟踪参数和子模块　183
8．3．3　函数式API　184
8．4　训练我们的convnet　185
8．4．1　测量精度　187
8．4．2　保存并加载我们的模型　188
8．4．3　在GPU上训练　188
8．5　模型设计　190
8．5．1　增加内存容量：宽度　191
8．5．2　帮助我们的模型收敛和泛化：正则化　192
8．5．3　深入学习更复杂的结构：深度　195
8．5．4　本节设计的比较　200
8．5．5　已经过时了　201
8．6　总结　201
8．7　练习题　201
8．8　本章小结　202
第　2部分 从现实世界的图像中学习：肺癌的早期检测
第9章　使用PyTorch来检测癌症　205
9．1　用例简介　205
9．2　为一个大型项目做准备　206
9．3　到底什么是CT扫描　207
9．4　项目：肺癌的端到端检测仪　210
9．4．1　为什么我们不把数据扔给神经网络直到它起作用呢　213
9．4．2　什么是结节　216
9．4．3　我们的数据来源：LUNA大挑战赛　217
9．4．4　下载LUNA数据集　218
9．5　总结　219
9．6　本章小结　219
第　10章 将数据源组合成统一的数据集　220
10．1　原始CT数据文件　222
10．2　解析LUNA的标注 数据　222
10．2．1　训练集和验证集　224
10．2．2　统一标注和候选 数据　225
10．3　加载单个CT扫描　227
10．4　使用病人坐标系定位结节　230
10．4．1　病人坐标系　230
10．4．2　CT扫描形状和体素大小　232
10．4．3　毫米和体素地址之间的转换　233
10．4．4　从CT扫描中取出一个结节　234
10．5　一个简单的数据集实现　235
10．5．1　使用getCtRawCandidate()函数缓存候选数组　238
10．5．2　在LunaDataset．__init__()中构造我们的数据集　238
10．5．3　分隔训练集和验证集　239
10．5．4　呈现数据　240
10．6　总结　241
10．7　练习题　241
10．8　本章小结　242
第　11章 训练分类模型以检测可疑肿瘤　243
11．1　一个基本的模型和训练循环　243
11．2　应用程序的主入口点　246
11．3　预训练和初始化　247
11．3．1　初始化模型和优化器　247
11．3．2　数据加载器的维护和供给　249
11．4　我们的首次神经网络设计　251
11．4．1　核心卷积　251
11．4．2　完整模型　254
11．5　训练和验证模型　257
11．5．1　computeBatchLoss()函数　258
11．5．2　类似的验证循环　260
11．6　输出性能指标　261
11．7　运行训练脚本　265
11．7．1　训练所需的数据　266
11．7．2　插曲：enumerateWithEstimate()函数　266
11．8　评估模型：得到99．7%的正确率是否意味着我们完成了任务　268
11．9　用TensorBoard绘制训练指标　269
11．9．1　运行TensorBoard　269
11．9．2　增加TensorBoard对指标记录函数的支持　272
11．10　为什么模型不学习检测结节　274
11．11　总结　275
11．12　练习题　275
11．13　本章小结　275
第　12章 通过指标和数据增强来提升训练　277
12．1　高级改进计划　278
12．2　好狗与坏狗：假阳性与假阴性　279
12．3　用图表表示阳性与阴性　280
12．3．1　召回率是Roxie的强项　282
12．3．2　精度是Preston的强项　283
12．3．3　在logMetrics()中实现精度和召回率　284
12．3．4　我们的终极性能指标：F1分数　285
12．3．5　我们的模型在新指标下表现如何　289
12．4　理想的数据集是什么样的　290
12．4．1　使数据看起来更理想化　292
12．4．2　使用平衡的LunaDataset与之前的数据集运行情况对比　296
12．4．3　认识过拟合　298
12．5　重新审视过拟合的问题　300
12．6　通过数据增强防止过拟合　300
12．6．1　具体的数据增强技术　301
12．6．2　看看数据增强带来的改进　306
12．7　总结　308
12．8　练习题　308
12．9　本章小结　309
第　13章 利用分割法寻找可疑结节　310
13．1　向我们的项目添加第 2个模型　310
13．2　各种类型的分割　312
13．3　语义分割：逐像素分类　313
13．4　更新分割模型　317
13．5　更新数据集以进行分割　319
13．5．1　U-Net有非常具体的对输入大小的要求　320
13．5．2　U-Net对三维和二维数据的权衡　320
13．5．3　构建真实、有效的数据集　321
13．5．4　实现Luna2dSegmentationDataset　327
13．5．5　构建训练和验证数据　331
13．5．6　实现TrainingLuna2dSegmentationDataset　332
13．5．7　在GPU上增强数据　333
13．6　更新用于分割的训练脚本　335
13．6．1　初始化分割和增强模型　336
13．6．2　使用Adam优化器　336
13．6．3　骰子损失　337
13．6．4　将图像导入TensorBoard　340
13．6．5　更新指标日志　343
13．6．6　保存模型　344
13．7　结果　345
13．8　总结　348
13．9　练习题　348
13．10　本章小结　349
第　14章 端到端的结节分析及下一步的方向　350
14．1　接近终点线　350
14．2　验证集的独立性　352
14．3　连接CT分割和候选结节分类　353
14．3．1　分割　354
14．3．2　将体素分组为候选结节　355
14．3．3　我们发现结节了吗？分类以减少假阳性　357
14．4　定量验证　360
14．5　预测恶性肿瘤　361
14．5．1　获取恶性肿瘤信息　361
14．5．2　曲线基线下的区域：按直径分类　362
14．5．3　重用预先存在的权重：微调　365
14．5．4　TensorBoard中的输出　370
14．6　在诊断时所见的内容　374
14．7　接下来呢？其他灵感和数据的来源　376
14．7．1　防止过拟合：更好的正则化　377
14．7．2　精细化训练数据　379
14．7．3　竞赛结果及研究论文　380
14．8　总结　381
14．9　练习题　382
14．10　本章小结　383
第3部分　部署
第　15章 部署到生产环境　387
15．1　PyTorch模型的服务　388
15．1．1　支持Flask服务的模型　388
15．1．2　我们想从部署中得到的东西　390
15．1．3　批处理请求　391
15．2　导出模型　395
15．2．1　PyTorch与ONNX的互操作性　396
15．2．2　PyTorch自己的导出：跟踪　397
15．2．3　具有跟踪模型的服务器　398
15．3　与PyTorch JIT编译器交互　398
15．3．1　超越经典Python/PyTorch的期望是什么　399
15．3．2　PyTorch作为接口和后端的双重特性　400
15．3．3　TorchScript　400
15．3．4　为可追溯的差异编写脚本　404
15．4　LibTorch：C++中的PyTorch　405
15．4．1　从C++中运行JITed模型　405
15．4．2　从C++ API开始　408
15．5　部署到移动设备　411
15．6　新兴技术：PyTorch
模型的企业服务　416
15．7　总结　416
15．8　练习题　416
15．9　本章小结　416
・ ・ ・ ・ ・ ・ (收起)