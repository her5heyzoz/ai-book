第一部分　元编程基础技术
第1章 基本技巧　3
1.1　元函数与type_traits　3
1.1.1　元函数介绍　3
1.1.2　类型元函数　4
1.1.3　各式各样的元函数　6
1.1.4　type_traits　7
1.1.5　元函数与宏　7
1.1.6　本书中元函数的命名方式　8
1.2　模板型模板参数与容器模板　8
1.2.1　模板作为元函数的输入　9
1.2.2　模板作为元函数的输出　9
1.2.3　容器模板　10
1.3　顺序、分支与循环代码的编写　12
1.3.1　顺序执行的代码　12
1.3.2　分支执行的代码　13
1.3.3　循环执行的代码　19
1.3.4　小心：实例化爆炸与编译崩溃　21
1.3.5　分支选择与短路逻辑　23
1.4　奇特的递归模板式　24
1.5　小结　25
1.6　练习　26
第2章 异类词典与policy模板　28
2.1　具名参数简介　28
2.2　异类词典　30
2.2.1　模块的使用方式　30
2.2.2　键的表示　32
2.2.3　异类词典的实现　34
2.2.4　VarTypeDict的性能简析　41
2.2.5　用std::tuple作为缓存　41
2.3　policy模板　42
2.3.1　policy介绍　42
2.3.2　定义policy与policy对象（模板）　45
2.3.3　使用policy　47
2.3.4　背景知识：支配与虚继承　49
2.3.5　policy对象与policy支配结构　50
2.3.6　policy选择元函数　52
2.3.7　使用宏简化policy对象的声明　57
2.4　小结　58
2.5　练习　58
第二部分 深度学习框架
第3章　深度学习概述　63
3.1　深度学习简介　63
3.1.1　从机器学习到深度学习　64
3.1.2　各式各样的人工神经网络　65
3.1.3　深度学习系统的组织与训练　68
3.2　本书所实现的框架：MetaNN　70
3.2.1　从矩阵计算工具到深度学习框架　70
3.2.2　MetaNN介绍　71
3.2.3　本书将要讨论的内容　72
3.2.4　本书不会涉及的主题　75
3.3　小结　75
第4章　类型体系与基本数据类型　76
4.1　类型体系　77
4.1.1　类型体系介绍　77
4.1.2　迭代器分类体系　78
4.1.3　将标签作为模板参数　80
4.1.4　MetaNN的类型体系　81
4.1.5　与类型体系相关的元函数　82
4.2　设计理念　84
4.2.1　支持不同的计算设备与计算单元　84
4.2.2　存储空间的分配与维护　85
4.2.3　浅拷贝与写操作检测　88
4.2.4　底层接口扩展　89
4.2.5　类型转换与求值　91
4.2.6　数据接口规范　92
4.3　标量　92
4.3.1　类模板的声明　93
4.3.2　基于CPU的特化版本　94
4.3.3　标量的主体类型　95
4.4　矩阵　96
4.4.1　Matrix类模板　96
4.4.2　特殊矩阵：平凡矩阵、全零矩阵与独热向量　101
4.4.3　引入新的矩阵类　104
4.5　列表　105
4.5.1　Batch模板　105
4.5.2　Array模板　108
4.5.3　重复与Duplicate模板　113
4.6　小结　116
4.7　练习　116
第5章　运算与表达式模板　119
5.1　表达式模板简介　119
5.2　MetaNN运算模板的设计思想　122
5.2.1　Add模板的问题　122
5.2.2　运算模板的行为分析　122
5.3　运算分类　124
5.4　辅助模板　125
5.4.1　辅助类模板OperElementType_/OperDeviceType_　125
5.4.2　辅助类模板OperXXX_　126
5.4.3　辅助类模板OperCateCal　126
5.4.4　辅助类模板OperOrganizer　128
5.4.5　辅助类模板OperSeq　130
5.5　运算模板的框架　131
5.5.1　运算模板的类别标签　131
5.5.2　UnaryOp的定义　132
5.6　运算实现示例　133
5.6.1　Sigmoid运算　133
5.6.2　Add运算　136
5.6.3　转置运算　139
5.6.4　折叠运算　141
5.7　MetaNN已支持的运算列表　141
5.7.1　一元运算　141
5.7.2　二元运算　142
5.7.3　三元运算　144
5.8　运算的折衷与局限性　144
5.8.1　运算的折衷　144
5.8.2　运算的局限性　145
5.9　小结　146
5.10　练习　146
第6章　基本层　148
6.1　层的设计理念　148
6.1.1　层的介绍　148
6.1.2　层对象的构造　150
6.1.3　参数矩阵的初始化与加载　151
6.1.4　正向传播　152
6.1.5　存储中间结果　154
6.1.6　反向传播　154
6.1.7　参数矩阵的更新　155
6.1.8　参数矩阵的获取　155
6.1.9　层的中性检测　156
6.2　层的辅助逻辑　156
6.2.1　初始化模块　156
6.2.2　DynamicData类模板　161
6.2.3　层的常用policy对象　166
6.2.4　InjectPolicy元函数　168
6.2.5　通用I/O结构　168
6.2.6　通用操作函数　169
6.3　层的具体实现　170
6.3.1　AddLayer　170
6.3.2　ElementMulLayer　172
6.3.3　BiasLayer　176
6.4　MetaNN已实现的基本层　181
6.5　小结　183
6.6　练习　184
第7章　复合层与循环层　185
7.1　复合层的接口与设计理念　186
7.1.1　基本结构　186
7.1.2　结构描述语法　187
7.1.3　policy的继承关系　188
7.1.4　policy的修正　189
7.1.5　复合层的构造函数　190
7.1.6　一个完整的复合层构造示例　190
7.2　policy继承与修正逻辑的实现　191
7.2.1　policy继承逻辑的实现　191
7.2.2　policy修正逻辑的实现　194
7.3　ComposeTopology的实现　195
7.3.1　功能介绍　195
7.3.2　拓扑排序算法介绍　195
7.3.3　ComposeTopology包含的主要步骤　196
7.3.4　结构描述子句与其划分　196
7.3.5　结构合法性检查　198
7.3.6　拓扑排序的实现　200
7.3.7　子层实例化元函数　203
7.4　ComposeKernel的实现　207
7.4.1　类模板的声明　208
7.4.2　子层对象管理　208
7.4.3　参数获取、梯度收集与中性检测　211
7.4.4　参数初始化与加载　212
7.4.5　正向传播　214
7.4.6　反向传播　221
7.5　复合层实现示例　221
7.6　循环层　222
7.6.1　GruStep　222
7.6.2　构建RecurrentLayer类模板　224
7.6.3　RecurrentLayer的使用　230
7.7　小结　230
7.8　练习　230
第8章　求值与优化　233
8.1　MetaNN的求值模型　234
8.1.1　运算的层次结构　234
8.1.2　求值子系统的模块划分　235
8.2　基本求值逻辑　242
8.2.1　主体类型的求值接口　242
8.2.2　非主体基本数据类型的求值　243
8.2.3　运算模板的求值　245
8.2.4　DyanmicData与求值　248
8.3　求值过程的优化　249
8.3.1　避免重复计算　249
8.3.2　同类计算合并　250
8.3.3　多运算协同优化　251
8.4　小结　258
8.5　练习　259
后记―方家休见笑，吾道本艰难　260
・ ・ ・ ・ ・ ・ (收起)